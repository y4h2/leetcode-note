/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagFolderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// types.ts
var SUBTREE_MARK = "\u2192 ";
var SUBTREE_MARK_REGEX = /\/â†’ /g;
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  targetFolders: "",
  scanDelay: 250,
  useTitle: true,
  reduceNestedParent: true,
  frontmatterKey: "title",
  useTagInfo: false,
  tagInfo: "pininfo.md",
  mergeRedundantCombination: false,
  useVirtualTag: false,
  doNotSimplifyTags: false,
  overrideTagClicking: false,
  useMultiPaneList: false,
  archiveTags: ""
};
var VIEW_TYPE_SCROLL = "tagfolder-view-scroll";
var EPOCH_MINUTE = 60;
var EPOCH_HOUR = EPOCH_MINUTE * 60;
var EPOCH_DAY = EPOCH_HOUR * 24;
var FRESHNESS_1 = "FRESHNESS_01";
var FRESHNESS_2 = "FRESHNESS_02";
var FRESHNESS_3 = "FRESHNESS_03";
var FRESHNESS_4 = "FRESHNESS_04";
var FRESHNESS_5 = "FRESHNESS_05";
var tagDispDict = {
  FRESHNESS_01: "\u{1F550}",
  FRESHNESS_02: "\u{1F4D6}",
  FRESHNESS_03: "\u{1F4D7}",
  FRESHNESS_04: "\u{1F4DA}",
  FRESHNESS_05: "\u{1F5C4}",
  _VIRTUAL_TAG_FRESHNESS: "\u231B",
  _VIRTUAL_TAG_CANVAS: "\u{1F4CB} Canvas"
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var VIEW_TYPE_TAGFOLDER_LIST = "tagfolder-view-list";
var OrderKeyTag = {
  NAME: "File name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance5, create_fragment5, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment5 ? create_fragment5($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var treeRoot = writable();
var currentFile = writable("");
var maxDepth = writable(0);
var searchString = writable("");
var tagInfo = writable({});
var tagFolderSetting = writable(DEFAULT_SETTINGS);
var selectedTags = writable();

// util.ts
function unique(items) {
  return [.../* @__PURE__ */ new Set([...items])];
}
function allTags(entry) {
  var _a;
  if ("tags" in entry)
    return entry.tags;
  return unique([...((_a = entry == null ? void 0 : entry.descendants) != null ? _a : []).flatMap((e) => e.tags), ...entry.children.flatMap((e) => "tag" in e ? allTags(e) : e.tags).filter((e) => e)]);
}
function isAutoExpandTree(entry, setting) {
  var _a;
  if (setting.doNotSimplifyTags)
    return false;
  if ("tag" in entry) {
    const childrenTags = entry.children.filter(
      (e) => "tag" in e
    );
    const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter(
      (e) => "tags" in e
    );
    if (childrenTags.length == 0)
      return false;
    if (entry.itemsCount == 1)
      return true;
    if (childrenTags.length == 1 && childrenItems.length == 0) {
      return true;
    }
    if (childrenTags.length == 1 && childrenItems.length > 1) {
      const sTags = allTags(entry).join("-").toLocaleLowerCase();
      for (const child of childrenItems) {
        const cTags = allTags(child).join("-").toLocaleLowerCase();
        if (sTags != cTags) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
function omittedTags(entry, setting) {
  var _a;
  if (setting.doNotSimplifyTags)
    return false;
  const childrenTags = entry.children.filter(
    (e) => "tag" in e
  );
  const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter(
    (e) => "tags" in e
  );
  if (childrenTags.length > 0)
    return false;
  const tx = childrenItems.map((e) => [...e.tags].sort().join("-"));
  if (tx.length != 1 && entry.itemsCount != 1)
    return false;
  const tags = unique(childrenItems.flatMap((e) => e.tags));
  const ancestorTags = ancestorToTags(entry.ancestors).map((e) => e.toLocaleLowerCase());
  const lastT = tags.filter((e) => !ancestorTags.contains(e.toLocaleLowerCase()));
  if (lastT.length) {
    return lastT;
  }
  return false;
}
function ancestorToTags(ancestors) {
  const SUBTREE_MARK_LENGTH = SUBTREE_MARK.length;
  return ancestors.reduce(
    (p, i) => !i.startsWith(SUBTREE_MARK) ? [...p, i] : [
      ...p,
      p.pop() + "/" + i.substring(SUBTREE_MARK_LENGTH)
    ],
    []
  );
}
function ancestorToLongestTag(ancestors) {
  return ancestors.reduceRight((a, e) => !a ? [e] : a[0].startsWith(e) ? a : [e, ...a], null);
}
function isSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag == "_untagged" || tag in tagDispDict;
}
var tagDispAlternativeDict = {};
tagInfo.subscribe((tagInfo2) => {
  tagDispAlternativeDict = { ...tagDispDict };
  if (tagInfo2 == null) {
    return;
  }
  const items = Object.entries(tagInfo2);
  for (const [key, info] of items) {
    if ("alt" in info) {
      tagDispAlternativeDict[key] = info.alt;
    }
  }
});
function renderSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag in tagDispAlternativeDict ? tagDispAlternativeDict[tag] : tagSrc;
}
function secondsToFreshness(totalAsMSec) {
  const totalAsSec = ~~(totalAsMSec / 1e3);
  const sign = totalAsSec / Math.abs(totalAsSec);
  const totalSec = ~~(totalAsSec * sign);
  if (totalSec < EPOCH_HOUR)
    return FRESHNESS_1;
  if (totalSec < EPOCH_HOUR * 6)
    return FRESHNESS_2;
  if (totalSec < EPOCH_DAY * 3)
    return FRESHNESS_3;
  if (totalSec < EPOCH_DAY * 7)
    return FRESHNESS_4;
  return FRESHNESS_5;
}
var queues = [];
function waitForRequestAnimationFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
function delay() {
  return new Promise((res) => setTimeout(() => res(), 5));
}
var waits = [waitForRequestAnimationFrame, waitForRequestAnimationFrame, delay];
var waitIdx = 0;
var pumping = false;
var startContinuousProcessing = Date.now();
async function pump() {
  if (pumping)
    return;
  try {
    pumping = true;
    do {
      const proc = queues.shift();
      if (proc) {
        proc();
        const now = Date.now();
        if (now - startContinuousProcessing > 22) {
          const w = waits[waitIdx];
          waitIdx = (waitIdx + 1) % waits.length;
          await w();
          startContinuousProcessing = Date.now();
        }
      } else {
        break;
      }
    } while (true);
  } finally {
    pumping = false;
  }
}
var doEvents = () => {
  return new Promise((res) => {
    const proc = () => {
      res();
    };
    queues.push(proc);
    pump();
  });
};
var compare = Intl && Intl.Collator ? new Intl.Collator().compare : (x, y) => `${x != null ? x : ""}`.localeCompare(`${y != null ? y : ""}`);
function pickEntry(entry, path, past = []) {
  const paths = typeof path == "string" ? path.split("/").slice(1) : path;
  const [head, ...tail] = paths;
  if (!entry)
    return null;
  if (!head)
    return entry;
  if (!("children" in entry)) {
    if (past.contains(head)) {
      return pickEntry(entry, tail, [...past, head.toLocaleLowerCase()]);
    } else {
      console.log("Picked leaf is not leaf");
      return null;
    }
  }
  const next = entry.children.find((e) => "tag" in e && compare(e.tag, head) == 0);
  if (!next) {
    if (past.contains(head)) {
      return pickEntry(entry, tail, [...past, head.toLocaleLowerCase()]);
    } else {
      console.log("Picking leaf looks something wrong");
      return null;
    }
  }
  return pickEntry(next, tail, [...past, head.toLocaleLowerCase()]);
}

// ScrollView.ts
var import_obsidian2 = require("obsidian");

// ScrollViewMarkdownComponent.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1qfikme", ".markdownBody.svelte-1qfikme{user-select:text;-webkit-user-select:text}");
}
function create_fragment(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "markdownBody svelte-1qfikme");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { file = { path: "" } } = $$props;
  let { observer } = $$props;
  let el;
  function onAppearing(_) {
    if (file.content && el) {
      import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
    }
  }
  onMount(() => {
    observer.observe(el);
    el.addEventListener("appearing", onAppearing);
  });
  onDestroy(() => {
    observer.unobserve(el);
    el.removeEventListener("appearing", onAppearing);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el), $$invalidate(1, file);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("observer" in $$props2)
      $$invalidate(2, observer = $$props2.observer);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $: {
        if (file && file.content && el) {
          $$invalidate(0, el.innerHTML = "", el);
          import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
        }
      }
    }
  };
  return [el, file, observer, div_binding];
}
var ScrollViewMarkdownComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { file: 1, observer: 2 }, add_css);
  }
};
var ScrollViewMarkdownComponent_default = ScrollViewMarkdownComponent;

// ScrollViewComponent.svelte
function add_css2(target) {
  append_styles(target, "svelte-s1mg0b", ".header.svelte-s1mg0b{background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);margin-bottom:8px}.file.svelte-s1mg0b{cursor:pointer}.path.svelte-s1mg0b{font-size:75%}hr.svelte-s1mg0b{margin:8px auto}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div1;
  let div0;
  let span0;
  let t0_value = ctx[11].title + "";
  let t0;
  let t1;
  let span1;
  let t2;
  let t3_value = ctx[11].path + "";
  let t3;
  let t4;
  let t5;
  let scrollviewmarkdown;
  let t6;
  let hr;
  let t7;
  let current;
  let mounted;
  let dispose;
  scrollviewmarkdown = new ScrollViewMarkdownComponent_default({
    props: {
      file: ctx[11],
      observer: ctx[1]
    }
  });
  function click_handler(...args) {
    return ctx[8](ctx[11], ...args);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("(");
      t3 = text(t3_value);
      t4 = text(")");
      t5 = space();
      create_component(scrollviewmarkdown.$$.fragment);
      t6 = space();
      hr = element("hr");
      t7 = space();
      attr(span1, "class", "path svelte-s1mg0b");
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "file svelte-s1mg0b");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      append(div1, t5);
      mount_component(scrollviewmarkdown, div1, null);
      append(div1, t6);
      append(div1, hr);
      append(div1, t7);
      ctx[9](div1);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 8) && t0_value !== (t0_value = ctx[11].title + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 8) && t3_value !== (t3_value = ctx[11].path + ""))
        set_data(t3, t3_value);
      const scrollviewmarkdown_changes = {};
      if (dirty & 8)
        scrollviewmarkdown_changes.file = ctx[11];
      if (dirty & 2)
        scrollviewmarkdown_changes.observer = ctx[1];
      scrollviewmarkdown.$set(scrollviewmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scrollviewmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrollviewmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(scrollviewmarkdown);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let hr;
  let t3;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text("Files in ");
      t1 = text(ctx[2]);
      t2 = space();
      hr = element("hr");
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "x");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t1, ctx2[2]);
      if (dirty & 27) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let files;
  let tagPath;
  let { store = writable({ files: [], title: "", tagPath: "" }) } = $$props;
  let { openfile } = $$props;
  let state = { files: [], title: "", tagPath: "" };
  function handleOpenFile(e, file) {
    openfile(file.path, false);
    e.preventDefault();
  }
  let scrollEl;
  let observer;
  const onAppearing = new CustomEvent("appearing", { detail: {} });
  onMount(() => {
    const options = {
      root: scrollEl,
      rootMargin: "10px",
      threshold: 0
    };
    $$invalidate(1, observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            entry.target.dispatchEvent(onAppearing);
          }
        }
      },
      options
    ));
  });
  onDestroy(() => {
    observer.disconnect();
  });
  const click_handler = (file, evt) => handleOpenFile(evt, file);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollEl = $$value;
      $$invalidate(0, scrollEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(5, store = $$props2.store);
    if ("openfile" in $$props2)
      $$invalidate(6, openfile = $$props2.openfile);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $: {
        store.subscribe((_state) => {
          $$invalidate(7, state = { ..._state });
          return () => {
          };
        });
      }
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, files = state.files);
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(2, tagPath = state.tagPath.split("/").map((e) => renderSpecialTag(e)).join("/"));
    }
  };
  return [
    scrollEl,
    observer,
    tagPath,
    files,
    handleOpenFile,
    store,
    openfile,
    state,
    click_handler,
    div1_binding
  ];
}
var ScrollViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { store: 5, openfile: 6 }, add_css2);
  }
};
var ScrollViewComponent_default = ScrollViewComponent;

// ScrollView.ts
var ScrollView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { files: [], title: "", tagPath: "" };
    this.plugin = plugin;
    this.store = writable({ files: [], title: "", tagPath: "" });
  }
  getIcon() {
    return "sheets-in-box";
  }
  getViewType() {
    return VIEW_TYPE_SCROLL;
  }
  getDisplayText() {
    return this.state.tagPath || "Tags scroll";
  }
  async setFile(filenames) {
    this.state = { ...this.state, files: filenames };
    await this.updateView();
  }
  async setState(state, result) {
    this.state = { ...state };
    this.title = state.title;
    await this.updateView();
    result = {};
    return;
  }
  getState() {
    return this.state;
  }
  isFileOpened(path) {
    return this.state.files.some((e) => e.path == path);
  }
  getScrollViewState() {
    return this.state;
  }
  async updateView() {
    const items = [];
    for (const item of this.state.files) {
      if (item.content) {
        items.push(item);
      } else {
        const f = this.app.vault.getAbstractFileByPath(item.path);
        if (f == null || !(f instanceof import_obsidian2.TFile)) {
          console.log(`File not found:${item.path}`);
          items.push(item);
          continue;
        }
        const title = this.plugin.getFileTitle(f);
        const w = await this.app.vault.read(f);
        await doEvents();
        item.content = w;
        item.title = title;
        items.push(item);
      }
    }
    this.state = { ...this.state, files: [...items] };
    this.store.set(this.state);
  }
  async onOpen() {
    this.component = new ScrollViewComponent_default({
      target: this.contentEl,
      props: {
        store: this.store,
        openfile: this.plugin.focusFile
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// TreeItemComponent.svelte
function add_css3(target) {
  append_styles(target, "svelte-etffjf", ".lsl-f.svelte-etffjf.svelte-etffjf{flex-direction:row;display:flex;flex-grow:1;overflow:hidden;max-width:calc(100%)}.tags.svelte-etffjf.svelte-etffjf{background-color:var(--background-secondary-alt);border-radius:4px;padding:2px 4px;margin-left:4px}.taglist.svelte-etffjf.svelte-etffjf{white-space:nowrap;text-overflow:ellipsis;padding-left:1em;overflow:hidden}.tagfolder-titletagname.svelte-etffjf.svelte-etffjf{flex-grow:1;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.nav-folder-title-content.svelte-etffjf:hover .tagfolder-quantity span.svelte-etffjf{background-color:var(--interactive-accent-hover);color:var(--text-on-accent)}.tagfolder-quantity.svelte-etffjf span.svelte-etffjf{background-color:var(--background-secondary-alt);border-radius:4px;padding:2px 4px}.tagfolder-quantity.svelte-etffjf.svelte-etffjf{width:3em;text-align:right;cursor:pointer;margin-left:auto}.tag-folder-title.svelte-etffjf.svelte-etffjf{max-width:100%}");
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  return child_ctx;
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div3;
  let div2;
  let div0;
  let t0_value = ctx[0].displayName + "";
  let t0;
  let t1;
  let div1;
  let mounted;
  let dispose;
  let each_value_2 = ctx[18];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "nav-file-title-content lsl-f svelte-etffjf");
      attr(div1, "class", "taglist svelte-etffjf");
      attr(div2, "class", "nav-file-title");
      toggle_class(div2, "is-active", ctx[14]);
      attr(div3, "class", "nav-file");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[41]),
          listen(div2, "mouseover", ctx[42]),
          listen(div2, "focus", focus_handler),
          listen(div2, "contextmenu", function() {
            if (is_function(ctx[24](ctx[0])))
              ctx[24](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1 && t0_value !== (t0_value = ctx[0].displayName + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 262144) {
        each_value_2 = ctx[18];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & 16384) {
        toggle_class(div2, "is-active", ctx[14]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let div2;
  let span;
  let t2_value = ctx[0].itemsCount + "";
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[17].length > 0 && create_if_block_3(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div1, "class", "tagfolder-titletagname svelte-etffjf");
      attr(span, "class", "itemscount svelte-etffjf");
      attr(div2, "class", "tagfolder-quantity itemscount svelte-etffjf");
      attr(div3, "class", "nav-folder-title-content lsl-f svelte-etffjf");
      attr(div4, "class", "nav-folder-title tag-folder-title svelte-etffjf");
      toggle_class(div4, "is-active", ctx[0].children && ctx[9] && ctx[14]);
      attr(div5, "class", "nav-folder");
      toggle_class(div5, "is-collapsed", ctx[9]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      div0.innerHTML = ctx[6];
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      div1.innerHTML = ctx[16];
      append(div3, t1);
      append(div3, div2);
      append(div2, span);
      append(span, t2);
      append(div5, t3);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[38]),
          listen(div2, "click", ctx[39]),
          listen(div4, "click", ctx[40]),
          listen(div4, "contextmenu", function() {
            if (is_function(ctx[24](ctx[0])))
              ctx[24](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 64)
        div0.innerHTML = ctx[6];
      ;
      if (!current || dirty[0] & 65536)
        div1.innerHTML = ctx[16];
      ;
      if ((!current || dirty[0] & 1) && t2_value !== (t2_value = ctx[0].itemsCount + ""))
        set_data(t2, t2_value);
      if (!current || dirty[0] & 16897) {
        toggle_class(div4, "is-active", ctx[0].children && ctx[9] && ctx[14]);
      }
      if (ctx[17].length > 0) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div5, "is-collapsed", ctx[9]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[17].length > 0 && create_if_block_1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[17].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block_2(ctx) {
  let span;
  let t_value = ctx[50] + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tags svelte-etffjf");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262144 && t_value !== (t_value = ctx2[50] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let current;
  let each_value_1 = ctx[17];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 688638) {
        each_value_1 = ctx2[17];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[45],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      path: ctx[19],
      folderIcon: ctx[6],
      isMainTree: ctx[7],
      parentTags: [
        ...ctx[8],
        ...ctx[15],
        "tag" in ctx[45] ? ctx[45].tag : void 0
      ]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 131072)
        treeitemcomponent_changes.entry = ctx2[45];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 524288)
        treeitemcomponent_changes.path = ctx2[19];
      if (dirty[0] & 64)
        treeitemcomponent_changes.folderIcon = ctx2[6];
      if (dirty[0] & 128)
        treeitemcomponent_changes.isMainTree = ctx2[7];
      if (dirty[0] & 164096)
        treeitemcomponent_changes.parentTags = [
          ...ctx2[8],
          ...ctx2[15],
          "tag" in ctx2[45] ? ctx2[45].tag : void 0
        ];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[17];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 692734) {
        each_value = ctx2[17];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[45],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      skippedTag: ctx[12],
      path: ctx[19],
      folderIcon: ctx[6],
      isMainTree: ctx[7],
      parentTags: [
        ...ctx[8],
        ...ctx[15],
        "tag" in ctx[45] ? ctx[45].tag : void 0
      ]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 131072)
        treeitemcomponent_changes.entry = ctx2[45];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 4096)
        treeitemcomponent_changes.skippedTag = ctx2[12];
      if (dirty[0] & 524288)
        treeitemcomponent_changes.path = ctx2[19];
      if (dirty[0] & 64)
        treeitemcomponent_changes.folderIcon = ctx2[6];
      if (dirty[0] & 128)
        treeitemcomponent_changes.isMainTree = ctx2[7];
      if (dirty[0] & 164096)
        treeitemcomponent_changes.parentTags = [
          ...ctx2[8],
          ...ctx2[15],
          "tag" in ctx2[45] ? ctx2[45].tag : void 0
        ];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function fallback_block(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 1025)
      show_if = null;
    if (ctx2[13])
      return 0;
    if (show_if == null)
      show_if = !!("tag" in ctx2[0] && (ctx2[20] <= ctx2[10] || ctx2[0].tag.startsWith(SUBTREE_MARK)));
    if (show_if)
      return 1;
    if ("path" in ctx2[0] && (ctx2[11].useMultiPaneList && !ctx2[7] || !ctx2[11].useMultiPaneList))
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment3(ctx) {
  let current;
  const default_slot_template = ctx[37].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[36], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[36],
            !current ? get_all_dirty_from_scope(ctx2[36]) : get_slot_changes(default_slot_template, ctx2[36], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 1048575)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function getItemPath(item, basepath) {
  if (item && "tag" in item) {
    return basepath + item.tag + "/";
  }
  return basepath;
}
function getFilenames(entry) {
  if (entry.allDescendants == null) {
    return [];
  } else {
    const filenames = entry.allDescendants.map((e) => e.path);
    return Array.from(/* @__PURE__ */ new Set([...filenames]));
  }
}
function getTagMark(tagInfo2) {
  if (!tagInfo2)
    return "";
  if ("key" in tagInfo2) {
    if ("mark" in tagInfo2 && tagInfo2.mark != "") {
      return tagInfo2.mark;
    } else {
      return "\u{1F4CC}";
    }
  } else {
    if ("mark" in tagInfo2 && tagInfo2.mark != "") {
      return tagInfo2.mark;
    } else {
      return "";
    }
  }
}
var focus_handler = () => {
};
function instance3($$self, $$props, $$invalidate) {
  let currentPath;
  let curTaginfo;
  let tagMark;
  let convertedTag;
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a;
  let { entry } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { showMenu } = $$props;
  let { path } = $$props;
  let { skippedTag } = $$props;
  let { openScrollView } = $$props;
  let { folderIcon } = $$props;
  let { isMainTree } = $$props;
  let { parentTags } = $$props;
  let collapsed = true;
  let isSelected = false;
  const currentDepth = path.replace(SUBTREE_MARK_REGEX, "###").split("/").length;
  let _maxDepth = currentDepth + 1;
  let setting = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
  tagFolderSetting.subscribe((newSetting) => {
    $$invalidate(11, setting = newSetting);
  });
  function toggleFolder(evt, entry2) {
    if (evt.target instanceof HTMLElement && evt.target.hasClass("itemscount"))
      return;
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(9, collapsed = !collapsed);
      if (setting.useMultiPaneList) {
        selectedTags.set(entry2.ancestors);
      }
    }
  }
  function toggleFolderExpandOnly(evt, entry2) {
    evt.stopImmediatePropagation();
    if (evt.target instanceof HTMLElement && evt.target.hasClass("itemscount"))
      return;
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(9, collapsed = !collapsed);
    }
    return;
  }
  function openfileLocal(entry2, evt) {
    if ("path" in entry2)
      openfile(entry2.path, evt.metaKey || evt.ctrlKey);
  }
  function handleContextMenu(e, path2, entry2) {
    showMenu(e, path2, entry2);
  }
  function contextMenuFunc(entry2) {
    const _path = currentPath;
    const _entry = entry2;
    return (e) => {
      handleContextMenu(e, _path, _entry);
    };
  }
  function handleMouseover(e, entry2) {
    if (entry2 && "path" in entry2)
      hoverPreview(e, entry2.path);
  }
  function handleOpenScroll(e, entry2) {
    if ("tag" in entry2) {
      openScrollView(null, "", entry2.ancestors.join("/"), entry2.allDescendants.map((e2) => e2.path));
      e.preventDefault();
    }
  }
  currentFile.subscribe((path2) => {
    $$invalidate(14, isSelected = false);
    if ("tags" in entry && entry.path == path2) {
      $$invalidate(14, isSelected = true);
    }
    if ("tag" in entry && getFilenames(entry).indexOf(path2) !== -1) {
      $$invalidate(14, isSelected = true);
    }
  });
  let _tagInfo = {};
  maxDepth.subscribe((depth) => {
    $$invalidate(10, _maxDepth = depth);
    if (depth == 0) {
      $$invalidate(10, _maxDepth = currentDepth + 1);
    }
  });
  tagInfo.subscribe((info) => {
    $$invalidate(30, _tagInfo = info);
  });
  let tagTitle = "";
  let showOnlyChildren = false;
  let ellipsisMarks = [];
  let omitTags = [];
  let omitTagSrc = [];
  const escapeStringToHTML = (str) => {
    if (!str)
      return "";
    return str.replace(/[<>&"'`]/g, (match) => {
      const escape = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#x60;"
      };
      return escape[match];
    });
  };
  let tagsTitleDispHtml = "";
  let children2 = [];
  let entryLeftTags = [];
  const click_handler = (evt) => toggleFolderExpandOnly(evt, entry);
  const click_handler_1 = (e) => handleOpenScroll(e, entry);
  const click_handler_2 = (evt) => toggleFolder(evt, entry);
  const click_handler_3 = (evt) => openfileLocal(entry, evt);
  const mouseover_handler = (e) => handleMouseover(e, entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("showMenu" in $$props2)
      $$invalidate(4, showMenu = $$props2.showMenu);
    if ("path" in $$props2)
      $$invalidate(27, path = $$props2.path);
    if ("skippedTag" in $$props2)
      $$invalidate(28, skippedTag = $$props2.skippedTag);
    if ("openScrollView" in $$props2)
      $$invalidate(5, openScrollView = $$props2.openScrollView);
    if ("folderIcon" in $$props2)
      $$invalidate(6, folderIcon = $$props2.folderIcon);
    if ("isMainTree" in $$props2)
      $$invalidate(7, isMainTree = $$props2.isMainTree);
    if ("parentTags" in $$props2)
      $$invalidate(8, parentTags = $$props2.parentTags);
    if ("$$scope" in $$props2)
      $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2049 | $$self.$$.dirty[1] & 2) {
      $: {
        $$invalidate(13, showOnlyChildren = false);
        $$invalidate(31, ellipsisMarks = []);
        $$invalidate(32, omitTags = []);
        $$invalidate(15, omitTagSrc = []);
        if ("tag" in entry) {
          $$invalidate(13, showOnlyChildren = isAutoExpandTree(entry, setting));
          const omitTag = omittedTags(entry, setting);
          if (omitTag !== false) {
            $$invalidate(15, omitTagSrc = omitTag);
            $$invalidate(32, omitTags = [
              ...omitTag.map((e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/"))
            ]);
            $$invalidate(31, ellipsisMarks = omitTags.map((e) => e.split("/")));
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 134217729 | $$self.$$.dirty[1] & 2) {
      $:
        $$invalidate(19, currentPath = getItemPath(entry, path) + omitTags.map((e) => "/" + e).join(""));
    }
    if ($$self.$$.dirty[0] & 1073741825) {
      $:
        $$invalidate(35, curTaginfo = "tag" in entry && entry.tag in _tagInfo ? _tagInfo[entry.tag] : null);
    }
    if ($$self.$$.dirty[1] & 16) {
      $:
        $$invalidate(34, tagMark = getTagMark(curTaginfo));
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(33, convertedTag = "tag" in entry ? renderSpecialTag(entry.tag) : "");
    }
    if ($$self.$$.dirty[0] & 268435457 | $$self.$$.dirty[1] & 12) {
      $:
        $$invalidate(12, tagTitle = "tag" in entry ? `${skippedTag ? `${skippedTag}${entry.tag.startsWith(SUBTREE_MARK) ? " " : " "}` : ""}${tagMark}${convertedTag}` : "");
    }
    if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 1) {
      $: {
        let tagsTitleDisp = [
          ...tagTitle.split(SUBTREE_MARK).join("/").split(" ").map((e) => e.split("/")),
          ...ellipsisMarks
        ];
        $$invalidate(16, tagsTitleDispHtml = tagsTitleDisp.map((e) => `<span class="tagfolder-tag tag-tag">${e.map((ee) => `<span class="tagfolder-tag tag-nested-tag">${escapeStringToHTML(ee)}</span>`).join("")}</span>`).join(""));
      }
    }
    if ($$self.$$.dirty[0] & 9729) {
      $: {
        let cx = [];
        if ("tag" in entry) {
          if (showOnlyChildren) {
            cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
          } else {
            if (entry.children && !collapsed) {
              cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
            }
            if (_maxDepth != 1 && currentDepth > _maxDepth && entry.allDescendants && !collapsed) {
              cx = [...cx, ...entry.allDescendants];
            }
            if (entry.descendants && !collapsed) {
              cx = [...cx, ...entry.descendants];
            }
          }
          $$invalidate(17, children2 = unique(cx));
        }
      }
    }
    if ($$self.$$.dirty[0] & 536871169) {
      $: {
        $$invalidate(18, entryLeftTags = []);
        if ("tags" in entry) {
          const tempTags = [..."tags" in entry ? entry.tags : []];
          const removeTags = [
            ...ancestorToLongestTag(ancestorToTags($$invalidate(29, _a = parentTags.filter((e) => e)) !== null && _a !== void 0 ? _a : []))
          ];
          let filteredTags = [...tempTags];
          for (const removeTag of removeTags) {
            const part = removeTag.split("/");
            for (const piece of part)
              filteredTags = filteredTags.map((e) => e == piece ? "" : e.startsWith(piece + "/") ? e.substring(piece.length + 1) : e);
          }
          $$invalidate(18, entryLeftTags = filteredTags.filter((e) => e.trim() != "").map((e) => renderSpecialTag(e)));
        }
      }
    }
  };
  return [
    entry,
    hoverPreview,
    openfile,
    expandFolder,
    showMenu,
    openScrollView,
    folderIcon,
    isMainTree,
    parentTags,
    collapsed,
    _maxDepth,
    setting,
    tagTitle,
    showOnlyChildren,
    isSelected,
    omitTagSrc,
    tagsTitleDispHtml,
    children2,
    entryLeftTags,
    currentPath,
    currentDepth,
    toggleFolder,
    toggleFolderExpandOnly,
    openfileLocal,
    contextMenuFunc,
    handleMouseover,
    handleOpenScroll,
    path,
    skippedTag,
    _a,
    _tagInfo,
    ellipsisMarks,
    omitTags,
    convertedTag,
    tagMark,
    curTaginfo,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    mouseover_handler
  ];
}
var TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        entry: 0,
        hoverPreview: 1,
        openfile: 2,
        expandFolder: 3,
        showMenu: 4,
        path: 27,
        skippedTag: 28,
        openScrollView: 5,
        folderIcon: 6,
        isMainTree: 7,
        parentTags: 8
      },
      add_css3,
      [-1, -1]
    );
  }
};
var TreeItemComponent_default = TreeItemComponent;

// TagFolderViewComponent.svelte
var import_obsidian3 = require("obsidian");
function add_css4(target) {
  append_styles(target, "svelte-1xm87ro", ".nav-files-container.svelte-1xm87ro{height:100%}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function create_if_block_22(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      attr(div0, "class", "clickable-icon nav-action-button");
      attr(div0, "aria-label", "Change sort order");
      attr(div1, "class", "clickable-icon nav-action-button");
      attr(div1, "aria-label", "Expand limit");
      attr(div2, "class", "clickable-icon nav-action-button");
      attr(div2, "aria-label", "Search");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      div0.innerHTML = ctx[16];
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      div1.innerHTML = ctx[17];
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      div2.innerHTML = ctx[18];
      if (!mounted) {
        dispose = [
          listen(div0, "click", function() {
            if (is_function(ctx[7]))
              ctx[7].apply(this, arguments);
          }),
          listen(div1, "click", function() {
            if (is_function(ctx[6]))
              ctx[6].apply(this, arguments);
          }),
          listen(div2, "click", ctx[22])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 65536)
        div0.innerHTML = ctx[16];
      ;
      if (dirty[0] & 131072)
        div1.innerHTML = ctx[17];
      ;
      if (dirty[0] & 262144)
        div2.innerHTML = ctx[18];
      ;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Switch List/Tree");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = ctx[19];
      if (!mounted) {
        dispose = listen(div, "click", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 524288)
        div.innerHTML = ctx2[19];
      ;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "search");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(div0, "display", ctx[11].trim() == "" ? "none" : "");
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(input, ctx[11]);
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[29]),
          listen(div0, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048) {
        set_input_value(input, ctx2[11]);
      }
      if (dirty[0] & 2048) {
        set_style(div0, "display", ctx2[11].trim() == "" ? "none" : "");
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block3(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent_default({
    props: {
      entry: ctx[30],
      hoverPreview: ctx[1],
      openfile: ctx[2],
      expandFolder: ctx[3],
      showMenu: ctx[5],
      skippedTag: "",
      path: "/",
      openScrollView: ctx[9],
      folderIcon: ctx[15],
      isMainTree: ctx[20],
      parentTags: [
        ...ctx[4],
        "tag" in ctx[30] ? ctx[30].tag : void 0
      ]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 1)
        treeitemcomponent_changes.entry = ctx2[30];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 32)
        treeitemcomponent_changes.showMenu = ctx2[5];
      if (dirty[0] & 512)
        treeitemcomponent_changes.openScrollView = ctx2[9];
      if (dirty[0] & 32768)
        treeitemcomponent_changes.folderIcon = ctx2[15];
      if (dirty[0] & 1048576)
        treeitemcomponent_changes.isMainTree = ctx2[20];
      if (dirty[0] & 17)
        treeitemcomponent_changes.parentTags = [
          ...ctx2[4],
          "tag" in ctx2[30] ? ctx2[30].tag : void 0
        ];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment4(ctx) {
  let div0;
  let t0;
  let div3;
  let div2;
  let div1;
  let t1;
  let t2;
  let t3;
  let t4;
  let div9;
  let div8;
  let div6;
  let div4;
  let t5;
  let div5;
  let t6;
  let t7;
  let div7;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[20] && create_if_block_22(ctx);
  let if_block1 = ctx[10] && create_if_block_12(ctx);
  let if_block2 = ctx[12] && ctx[20] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      div9 = element("div");
      div8 = element("div");
      div6 = element("div");
      div4 = element("div");
      t5 = space();
      div5 = element("div");
      t6 = text(ctx[21]);
      t7 = space();
      div7 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      div0.hidden = true;
      attr(div1, "class", "clickable-icon nav-action-button");
      attr(div1, "aria-label", "New note");
      attr(div2, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div3, "class", "nav-header");
      attr(div4, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div5, "class", "nav-folder-title-content");
      attr(div6, "class", "nav-folder-title");
      attr(div7, "class", "nav-folder-children");
      attr(div8, "class", "nav-folder mod-root");
      attr(div9, "class", "nav-files-container svelte-1xm87ro");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      ctx[28](div0);
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      div1.innerHTML = ctx[14];
      append(div2, t1);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, div9, anchor);
      append(div9, div8);
      append(div8, div6);
      append(div6, div4);
      append(div6, t5);
      append(div6, div5);
      append(div5, t6);
      append(div8, t7);
      append(div8, div7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div7, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", function() {
          if (is_function(ctx[8]))
            ctx[8].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 16384)
        div1.innerHTML = ctx[14];
      ;
      if (ctx[20]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_22(ctx);
          if_block0.c();
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[10]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_12(ctx);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx[12] && ctx[20]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block2(ctx);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & 2097152)
        set_data(t6, ctx[21]);
      if (dirty[0] & 1081919) {
        each_value = ctx[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div7, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      ctx[28](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div9);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let headerTitle;
  let isMainTree;
  let { items = [] } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { vaultname = "" } = $$props;
  let { title = "" } = $$props;
  let { tags = [] } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { openScrollView } = $$props;
  let { isViewSwitchable } = $$props;
  let { switchView } = $$props;
  treeRoot.subscribe((root) => {
    var _a;
    if (tags.length == 0) {
      $$invalidate(0, items = (_a = root === null || root === void 0 ? void 0 : root.children) !== null && _a !== void 0 ? _a : []);
    } else {
      const pickedRoot = pickEntry(root, tags);
      if (pickedRoot && "tag" in pickedRoot) {
        $$invalidate(0, items = pickedRoot.allDescendants || pickedRoot.children.filter((e) => "tags" in e));
      } else {
        console.warn(`Could not pick root:${tags.join(", ")}`);
        console.warn(root);
        $$invalidate(0, items = []);
      }
    }
  });
  let search = "";
  searchString.subscribe((newSearch) => {
    if (search != newSearch) {
      if (newSearch != "") {
        $$invalidate(12, showSearch = true);
      }
      $$invalidate(11, search = newSearch);
    }
  });
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(12, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(11, search = "");
    }
  }
  function clearSearch() {
    $$invalidate(11, search = "");
  }
  function doSwitch() {
    if (switchView) {
      switchView();
    }
  }
  let iconDivEl;
  let documentIcon = "";
  let folderIcon = "";
  let upAndDownArrowsIcon = "";
  let stackedLevels = "";
  let searchIcon = "";
  let switchIcon = "";
  onMount(async () => {
    (0, import_obsidian3.setIcon)(iconDivEl, "right-triangle");
    $$invalidate(15, folderIcon = `${iconDivEl.innerHTML}`);
    (0, import_obsidian3.setIcon)(iconDivEl, "document");
    $$invalidate(14, documentIcon = `${iconDivEl.innerHTML}`);
    if (isMainTree) {
      (0, import_obsidian3.setIcon)(iconDivEl, "lucide-sort-asc");
      $$invalidate(16, upAndDownArrowsIcon = iconDivEl.innerHTML);
      (0, import_obsidian3.setIcon)(iconDivEl, "stacked-levels");
      $$invalidate(17, stackedLevels = iconDivEl.innerHTML);
      (0, import_obsidian3.setIcon)(iconDivEl, "search");
      $$invalidate(18, searchIcon = iconDivEl.innerHTML);
    }
    (0, import_obsidian3.setIcon)(iconDivEl, "lucide-arrow-left-right");
    $$invalidate(19, switchIcon = iconDivEl.innerHTML);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconDivEl = $$value;
      $$invalidate(13, iconDivEl);
    });
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(11, search);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("vaultname" in $$props2)
      $$invalidate(25, vaultname = $$props2.vaultname);
    if ("title" in $$props2)
      $$invalidate(26, title = $$props2.title);
    if ("tags" in $$props2)
      $$invalidate(4, tags = $$props2.tags);
    if ("showMenu" in $$props2)
      $$invalidate(5, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(6, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(7, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(8, newNote = $$props2.newNote);
    if ("openScrollView" in $$props2)
      $$invalidate(9, openScrollView = $$props2.openScrollView);
    if ("isViewSwitchable" in $$props2)
      $$invalidate(10, isViewSwitchable = $$props2.isViewSwitchable);
    if ("switchView" in $$props2)
      $$invalidate(27, switchView = $$props2.switchView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2048) {
      $: {
        searchString.set(search);
      }
    }
    if ($$self.$$.dirty[0] & 100663296) {
      $:
        $$invalidate(21, headerTitle = title == "" ? `Tags: ${vaultname}` : `Items: ${title}`);
    }
    if ($$self.$$.dirty[0] & 16) {
      $:
        $$invalidate(20, isMainTree = tags.length == 0);
    }
  };
  return [
    items,
    hoverPreview,
    openfile,
    expandFolder,
    tags,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    openScrollView,
    isViewSwitchable,
    search,
    showSearch,
    iconDivEl,
    documentIcon,
    folderIcon,
    upAndDownArrowsIcon,
    stackedLevels,
    searchIcon,
    switchIcon,
    isMainTree,
    headerTitle,
    toggleSearch,
    clearSearch,
    doSwitch,
    vaultname,
    title,
    switchView,
    div0_binding,
    input_input_handler
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        items: 0,
        hoverPreview: 1,
        openfile: 2,
        expandFolder: 3,
        vaultname: 25,
        title: 26,
        tags: 4,
        showMenu: 5,
        showLevelSelect: 6,
        showOrder: 7,
        newNote: 8,
        openScrollView: 9,
        isViewSwitchable: 10,
        switchView: 27
      },
      add_css4,
      [-1, -1]
    );
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// TagFolderViewBase.ts
var import_obsidian5 = require("obsidian");

// dialog.ts
var import_obsidian4 = require("obsidian");
var askString = (app2, title, placeholder, initialText) => {
  return new Promise((res) => {
    const popover = new PopoverSelectString(app2, title, placeholder, initialText, (result) => res(result));
    popover.open();
  });
};
var PopoverSelectString = class extends import_obsidian4.SuggestModal {
  constructor(app2, title, placeholder, initialText, callback) {
    super(app2);
    this.callback = () => {
    };
    this.title = "";
    this.app = app2;
    this.title = title;
    this.setPlaceholder(placeholder != null ? placeholder : ">");
    this.callback = callback;
    setTimeout(() => {
      this.inputEl.value = initialText;
    });
    const parent = this.containerEl.querySelector(".prompt");
    if (parent) {
      parent.addClass("override-input");
    }
  }
  getSuggestions(query) {
    return [query];
  }
  renderSuggestion(value, el) {
    el.createDiv({ text: `${this.title}${value}` });
  }
  onChooseSuggestion(item, evt) {
    this.callback(item);
    this.callback = null;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback != null) {
        this.callback(false);
      }
    }, 100);
  }
};

// TagFolderViewBase.ts
function toggleObjectProp(obj, propName, value) {
  if (value === false) {
    const newTagInfoEntries = Object.entries(obj || {}).filter(([key]) => key != propName);
    if (newTagInfoEntries.length == 0) {
      return {};
    } else {
      return Object.fromEntries(newTagInfoEntries);
    }
  } else {
    return { ...obj != null ? obj : {}, [propName]: value };
  }
}
var TagFolderViewBase = class extends import_obsidian5.ItemView {
  showOrder(evt) {
    const menu = new import_obsidian5.Menu();
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick(async (evt2) => {
        const menu2 = new import_obsidian5.Menu();
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(
                OrderKeyTag[key] + " " + OrderDirection[direction]
              ).onClick(async () => {
                this.plugin.settings.sortTypeTag = newSetting;
                await this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              });
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      });
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick(async (evt2) => {
        const menu2 = new import_obsidian5.Menu();
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(
                OrderKeyItem[key] + " " + OrderDirection[direction]
              ).onClick(async () => {
                this.plugin.settings.sortType = newSetting;
                await this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              });
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      });
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian5.Menu();
    const setLevel = async (level) => {
      this.plugin.settings.expandLimit = level;
      await this.plugin.saveSettings();
      maxDepth.set(level);
      this.plugin.setRoot(this.plugin.root);
    };
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showMenu(evt, path, entry) {
    const entryPath = "tag" in entry ? [...ancestorToTags(entry.ancestors)] : ["root", ...entry.tags];
    if ("tag" in entry) {
      const oTags = omittedTags(entry, this.plugin.settings);
      if (oTags != false) {
        entryPath.push(...oTags);
      }
    }
    entryPath.shift();
    const expandedTagsAll = ancestorToLongestTag(ancestorToTags(entryPath));
    const expandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => !isSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const displayExpandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => renderSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian5.Menu();
    if (navigator && navigator.clipboard) {
      menu.addItem(
        (item) => item.setTitle(`Copy tags:${expandedTags}`).setIcon("hashtag").onClick(async () => {
          await navigator.clipboard.writeText(expandedTags);
          new import_obsidian5.Notice("Copied");
        })
      );
    }
    menu.addItem(
      (item) => item.setTitle(`New note ${"tag" in entry ? "in here" : "as like this"}`).setIcon("create-new").onClick(async () => {
        const ww = await this.app.fileManager.createAndOpenMarkdownFile();
        await this.app.vault.append(ww, expandedTags);
      })
    );
    if ("tag" in entry) {
      if (this.plugin.settings.useTagInfo && this.plugin.tagInfo != null) {
        const tag = entry.ancestors[entry.ancestors.length - 1];
        if (tag in this.plugin.tagInfo && "key" in this.plugin.tagInfo[tag]) {
          menu.addItem(
            (item) => item.setTitle(`Unpin`).setIcon("pin").onClick(async () => {
              this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "key", false);
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            })
          );
        } else {
          menu.addItem((item) => {
            item.setTitle(`Pin`).setIcon("pin").onClick(async () => {
              this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "key", "");
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle(`Set an alternative label`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldAlt = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].alt) != null ? _a : "" : "";
            const label = await askString(this.app, "", "", oldAlt);
            if (label === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "alt", label == "" ? false : label);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Change the mark`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldMark = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].mark) != null ? _a : "" : "";
            const mark = await askString(this.app, "", "", oldMark);
            if (mark === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "mark", mark == "" ? false : mark);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Redirect this tag to ...`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldRedirect = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].redirect) != null ? _a : "" : "";
            const redirect = await askString(this.app, "", "", oldRedirect);
            if (redirect === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "redirect", redirect == "" ? false : redirect);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Open scroll view`).setIcon("sheets-in-box").onClick(async () => {
            const files = entry.allDescendants.map((e) => e.path);
            const tagPath = entry.ancestors.join("/");
            await this.plugin.openScrollView(null, displayExpandedTags, tagPath, files);
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Open list`).setIcon("sheets-in-box").onClick(async () => {
            selectedTags.set(
              entry.ancestors
            );
          });
        });
      }
    }
    if ("path" in entry) {
      const path2 = entry.path;
      const file = this.app.vault.getAbstractFileByPath(path2);
      this.app.workspace.trigger(
        "file-menu",
        menu,
        file,
        "file-explorer"
      );
    }
    if ("tags" in entry) {
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle(`Open in new tab`).setIcon("lucide-file-plus").onClick(async () => {
          app.workspace.openLinkText(entry.path, entry.path, "tab");
        })
      );
      menu.addItem(
        (item) => item.setTitle(`Open to the right`).setIcon("lucide-separator-vertical").onClick(async () => {
          app.workspace.openLinkText(entry.path, entry.path, "split");
        })
      );
    }
    if ("screenX" in evt) {
      menu.showAtPosition({ x: evt.pageX, y: evt.pageY });
    } else {
      menu.showAtPosition({
        x: evt.nativeEvent.locationX,
        y: evt.nativeEvent.locationY
      });
    }
  }
  switchView() {
    const viewType = this.getViewType() == VIEW_TYPE_TAGFOLDER ? VIEW_TYPE_TAGFOLDER_LIST : VIEW_TYPE_TAGFOLDER;
    const leaves = this.app.workspace.getLeavesOfType(viewType).filter((e) => !e.getViewState().pinned && e != this.leaf);
    if (leaves.length) {
      this.app.workspace.revealLeaf(
        leaves[0]
      );
    }
  }
};

// TagFolderView.ts
var TagFolderView = class extends TagFolderViewBase {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
  }
  getIcon() {
    return "stacked-levels";
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  async onOpen() {
    this.containerEl.empty();
    this.component = new TagFolderViewComponent_default({
      target: this.containerEl,
      props: {
        openfile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        expandFolder: this.plugin.expandFolder,
        vaultname: this.app.vault.getName(),
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
};

// TagFolderList.ts
var TagFolderList = class extends TagFolderViewBase {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { tags: [], title: "" };
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
  }
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    menu.addItem((item) => {
      item.setIcon("pin").setTitle("Pin").onClick(() => {
        this.leaf.togglePinned();
      });
    });
  }
  getIcon() {
    return "stacked-levels";
  }
  async setState(state, result) {
    var _a;
    this.state = { ...state };
    this.title = state.tags.join(",");
    this.component.$set({ tags: state.tags, title: (_a = state.title) != null ? _a : "" });
    result = {};
    return;
  }
  getState() {
    return this.state;
  }
  async newNote(evt) {
    const expandedTags = this.state.tags.map((e) => e.split("/").filter((ee) => !isSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const ww = await this.app.fileManager.createAndOpenMarkdownFile();
    await this.app.vault.append(ww, expandedTags);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER_LIST;
  }
  getDisplayText() {
    return `Files with ${this.state.title}`;
  }
  async onOpen() {
    this.component = new TagFolderViewComponent_default({
      target: this.contentEl,
      props: {
        openfile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        expandFolder: this.plugin.expandFolder,
        title: "",
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        items: [],
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
};

// main.ts
var HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};
var dotted = (object, notation) => {
  return notation.split(".").reduce((a, b) => a && b in a ? a[b] : null, object);
};
var rippleDirty = (entry) => {
  for (const child of entry.children) {
    if ("tag" in child) {
      if (rippleDirty(child)) {
        entry.descendants = null;
        entry.allDescendants = null;
        entry.descendantsMemo = null;
      }
    }
  }
  if (entry.descendants == null)
    return true;
};
var retrieveAllDescendants = (entry) => {
  return ("tag" in entry ? entry.children.map(
    (e) => "tag" in e ? [...e.descendants, ...retrieveAllDescendants(e)] : [e]
  ) : [entry]).flat();
};
var retrieveChildren = (entry) => {
  return ("tag" in entry ? entry.children.map(
    (e) => "tag" in e ? [...retrieveChildren(e)] : [e]
  ) : [entry]).flat();
};
var expandDescendants = (entry, hideItems) => {
  const ret = [];
  for (const v of entry.children) {
    if ("tag" in v) {
      if (v.descendants == null) {
        const w = expandDescendants(v, hideItems).filter(
          (e) => !ret.contains(e)
        );
        ret.push(...w);
      } else {
        const w = v.descendants.filter((e) => !ret.contains(e));
        ret.push(...w);
      }
    } else {
      if (!ret.contains(v))
        ret.push(v);
    }
  }
  const leafs = entry.descendantsMemo != null ? entry.descendantsMemo : entry.descendantsMemo = [...new Set(entry.children.map(
    (e) => "tag" in e ? e.children.map(
      (ee) => retrieveAllDescendants(ee).flat()
    ).flat() : []
  ).flat())];
  if (hideItems == "DEDICATED_INTERMIDIATES" && entry.isDedicatedTree || hideItems == "ALL_EXCEPT_BOTTOM") {
    entry.descendants = ret.filter((e) => !leafs.contains(e));
  } else {
    entry.descendants = ret;
  }
  entry.allDescendants = ret;
  entry.itemsCount = (/* @__PURE__ */ new Set([...ret, ...leafs])).size;
  return ret;
};
var expandTree = async (node, reduceNestedParent) => {
  let modified = false;
  const tree = node.children;
  const ancestor = [...node.ancestors];
  const tags = Array.from(
    new Set(
      node.children.filter((e) => "tags" in e).map((e) => e.tags).flat()
    )
  );
  const ancestorAsTags = ancestorToTags(ancestor);
  for (const tag of tags) {
    if (ancestorAsTags.map((e) => e.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()))
      continue;
    const newChildren = node.children.filter(
      (e) => "tags" in e && e.tags.map((e2) => e2.toLocaleLowerCase()).contains(tag.toLocaleLowerCase())
    );
    if (tree.find(
      (e) => "tag" in e && e.tag.toLocaleLowerCase() == tag.toLocaleLowerCase()
    )) {
      continue;
    }
    const newLeaf = {
      tag,
      children: newChildren,
      ancestors: [...ancestor, tag],
      descendants: null,
      isDedicatedTree: false,
      itemsCount: newChildren.length,
      allDescendants: null
    };
    tree.push(newLeaf);
  }
  modified = await splitTag(node, reduceNestedParent) || modified;
  if (modified) {
    await expandTree(node, reduceNestedParent);
  }
  return modified;
};
var splitTag = async (entry, reduceNestedParent, root) => {
  let modified = false;
  const xRoot = root || entry;
  await doEvents();
  entry.children = entry.children.sort((a, b) => {
    if ("tag" in a && "tag" in b) {
      return a.tag.split("/").length - b.tag.split("/").length;
    } else {
      return 0;
    }
  });
  for (const curEntry of entry.children) {
    if ("tag" in curEntry) {
      modified = await splitTag(curEntry, reduceNestedParent, xRoot) || modified;
      if (curEntry.tag.contains("/")) {
        const tempEntry = curEntry;
        entry.children.remove(tempEntry);
        const tagsArray = tempEntry.tag.split("/");
        const tagCar = tagsArray.shift();
        const tagCdr = SUBTREE_MARK + tagsArray.join("/");
        const ancestors = curEntry.ancestors.map((e) => e.toLocaleLowerCase());
        const newAncestorsBase = tempEntry.ancestors.filter((e) => e != tempEntry.tag);
        const idxCar = ancestors.indexOf(tagCar.toLocaleLowerCase());
        const idxCdr = ancestors.indexOf(tagCdr.toLocaleLowerCase());
        if (idxCar != -1) {
          if (idxCar < idxCdr) {
            modified = true;
            continue;
          } else {
            if (reduceNestedParent) {
              modified = true;
              const replacer = {
                ...tempEntry,
                tag: tagCdr,
                ancestors: [
                  ...newAncestorsBase,
                  tagCar,
                  tagCdr
                ],
                itemsCount: 0,
                descendants: null,
                allDescendants: null,
                isDedicatedTree: tempEntry.isDedicatedTree
              };
              const old = entry.children.find((e) => "tag" in e && e.tag == tagCdr);
              if (old) {
                entry.children.remove(old);
                replacer.children = [...replacer.children, ...old.children];
              }
              entry.children.push(replacer);
              continue;
            }
          }
        }
        const parent = entry.children.find(
          (e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCar.toLocaleLowerCase()
        );
        const tempChildren = tempEntry.children;
        if (!parent) {
          const newGrandchild = {
            tag: tagCdr,
            children: [...tempChildren],
            ancestors: [
              ...newAncestorsBase,
              tagCar,
              tagCdr
            ],
            itemsCount: 0,
            descendants: null,
            allDescendants: null,
            isDedicatedTree: false
          };
          const newChild = {
            tag: tagCar,
            children: [newGrandchild],
            ancestors: [...newAncestorsBase, tagCar],
            descendants: null,
            allDescendants: null,
            isDedicatedTree: true,
            itemsCount: 0
          };
          newChild.children = [newGrandchild];
          entry.children.push(newChild);
          await splitTag(entry, reduceNestedParent, xRoot);
          modified = true;
        } else {
          const oldIx = parent.children.find(
            (e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCdr.toLocaleLowerCase()
          );
          if (oldIx != null) {
            oldIx.children.push(
              ...tempChildren.filter(
                (e) => !oldIx.children.contains(e)
              )
            );
            await splitTag(oldIx, reduceNestedParent, xRoot);
          } else {
            const x = {
              tag: tagCdr,
              children: [...tempChildren],
              ancestors: [
                ...newAncestorsBase,
                tagCar,
                tagCdr
              ],
              descendants: null,
              allDescendants: null,
              isDedicatedTree: false,
              itemsCount: 0
            };
            parent.children.push(x);
            if (!parent.isDedicatedTree) {
              const p = retrieveChildren(parent).map((e) => e.path);
              const c = retrieveChildren(tempEntry).map((e) => e.path);
              if (c.some((entry2) => !p.contains(entry2))) {
                parent.isDedicatedTree = false;
              } else {
                parent.isDedicatedTree = true;
              }
            }
            await splitTag(parent, reduceNestedParent, xRoot);
          }
          modified = true;
        }
      }
    }
  }
  if (modified) {
    modified = await splitTag(entry, reduceNestedParent, xRoot);
  }
  if (modified) {
    if (entry.isDedicatedTree && entry.children.some((e) => "tags" in e)) {
      entry.isDedicatedTree = false;
    }
  }
  return modified;
};
function getTagName(tagName, tagInfo2, invert) {
  if (tagInfo2 == null)
    return tagName;
  const prefix = invert == -1 ? `\uFFFF` : ``;
  const unpinned = invert == 1 ? `\uFFFF` : ``;
  if (tagName in tagInfo2 && tagInfo2[tagName]) {
    if ("key" in tagInfo2[tagName]) {
      return `${prefix}_-${tagInfo2[tagName].key}__${tagName}`;
    }
  }
  return `${prefix}_${unpinned}_${tagName}`;
}
function getCompareMethodTags(settings) {
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b, tagInfo2) => {
        const aCount = a.itemsCount - (settings.useTagInfo && (a.tag in tagInfo2 && "key" in tagInfo2[a.tag]) ? 1e5 * invert : 0);
        const bCount = b.itemsCount - (settings.useTagInfo && (b.tag in tagInfo2 && "key" in tagInfo2[b.tag]) ? 1e5 * invert : 0);
        return (aCount - bCount) * invert;
      };
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b, tagInfo2) => compare(getTagName(a.tag, settings.useTagInfo ? tagInfo2 : null, invert), getTagName(b.tag, settings.useTagInfo ? tagInfo2 : null, invert)) * invert;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b, tagInfo2) => compare(a.tag, b.tag) * invert;
  }
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => compare(a.displayName, b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => compare(a.path, b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "CTIME_ASC":
    case "CTIME_DESC":
      return (a, b) => (a.ctime - b.ctime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => compare(a.filename, b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => compare(a.displayName, b.displayName) * invert;
  }
}
function onElement(el, event, selector, callback, options) {
  el.on(event, selector, callback, options);
  return () => el.off(event, selector, callback, options);
}
var TagFolderPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.expandedFolders = ["root"];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.focusFile = (path, specialKey) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        if (specialKey) {
          app.workspace.openLinkText(targetFile.path, targetFile.path, "split");
        } else {
          app.workspace.openLinkText(targetFile.path, targetFile.path);
        }
      }
    };
    this.expandFolder = async (entry, expanded) => {
      if ("tag" in entry) {
        const key = [...entry.ancestors].join("/");
        if (expanded) {
          this.expandedFolders = Array.from(
            /* @__PURE__ */ new Set([...this.expandedFolders, key])
          );
          this.expandedFolders = this.expandedFolders.sort(
            (a, b) => a.split("/").length - b.split("/").length
          );
        } else {
          this.expandedFolders = this.expandedFolders.filter(
            (e) => e != key
          );
        }
        await this.expandLastExpandedFolders(entry);
        this.setRoot(this.root);
      }
    };
    this.fileCaches = [];
    this.oldFileCache = "";
    this.lastSettings = "";
    this.lastSearchString = "";
    this.tagInfo = null;
    this.tagInfoFrontMatterBuffer = {};
    this.tagInfoBody = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(
      VIEW_TYPE_TAGFOLDER
    )) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    searchString.set(search);
  }
  async expandLastExpandedFolders(entry, force, path = [], openedTags = {}, maxDepth2 = 1) {
    if (maxDepth2 < 0) {
      return;
    }
    if ("tag" in entry) {
      if (path.indexOf(entry.tag) !== -1)
        return;
      if (omittedTags(entry, this.settings))
        return;
      const key = entry.ancestors.join("/");
      for (const tags of this.expandedFolders) {
        const tagPrefixToOpen = [];
        const tagArray = tags.split("/");
        for (const f of tagArray) {
          tagPrefixToOpen.push(f);
          const tagPrefix = tagPrefixToOpen.join("/");
          if (!(tagPrefix in openedTags)) {
            openedTags[tagPrefix] = /* @__PURE__ */ new Set();
          }
          if (openedTags[tagPrefix].has(key)) {
            continue;
          }
          if (key.startsWith(tagPrefix) || force) {
            openedTags[tagPrefix].add(key);
            await expandTree(entry, this.settings.reduceNestedParent);
            await splitTag(entry, this.settings.reduceNestedParent);
            for (const child of entry.children) {
              if ("tag" in child) {
                const autoExp = isAutoExpandTree(child, this.settings);
                const nextDepth = autoExp || child.isDedicatedTree ? maxDepth2 : maxDepth2 - 1;
                if (path.indexOf(child.tag) == -1) {
                  await this.expandLastExpandedFolders(child, false, [...path, entry.tag], openedTags, nextDepth);
                }
              }
            }
          }
        }
      }
    }
  }
  getFileTitle(file) {
    if (!this.settings.useTitle)
      return file.basename;
    const metadata = this.app.metadataCache.getCache(file.path);
    if (metadata.frontmatter && this.settings.frontmatterKey) {
      const d = dotted(metadata.frontmatter, this.settings.frontmatterKey);
      if (d)
        return d;
    }
    if (metadata.headings) {
      const h1 = metadata.headings.find((e) => e.level == 1);
      if (h1) {
        return h1.heading;
      }
    }
    return file.basename;
  }
  getDisplayName(file) {
    const filename = this.getFileTitle(file) || file.basename;
    if (this.settings.displayMethod == "NAME") {
      return filename;
    }
    const path = file.path.split("/");
    path.pop();
    const displayPath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${filename} : ${displayPath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${displayPath}/${filename}`;
    }
    return filename;
  }
  async onload() {
    await this.loadSettings();
    this.hoverPreview = this.hoverPreview.bind(this);
    this.sortChildren = this.sortChildren.bind(this);
    this.modifyFile = this.modifyFile.bind(this);
    this.setSearchString = this.setSearchString.bind(this);
    this.openScrollView = this.openScrollView.bind(this);
    this.loadFileInfo = (0, import_obsidian6.debounce)(
      this.loadFileInfo.bind(this),
      this.settings.scanDelay,
      true
    );
    this.registerView(
      VIEW_TYPE_TAGFOLDER,
      (leaf) => new TagFolderView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_TAGFOLDER_LIST,
      (leaf) => new TagFolderList(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_SCROLL,
      (leaf) => new ScrollView(leaf, this)
    );
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.alwaysOpen) {
        await this.activateView();
      }
    });
    this.addCommand({
      id: "tagfolder-open",
      name: "Show Tag Folder",
      callback: () => {
        this.activateView();
      }
    });
    this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
    this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
    this.registerEvent(
      this.app.metadataCache.on("changed", this.metadataCacheChanged)
    );
    this.refreshAllTree = this.refreshAllTree.bind(this);
    this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("modify", this.modifyFile));
    this.registerEvent(
      this.app.workspace.on("file-open", this.watchWorkspaceOpen)
    );
    this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
    this.addSettingTab(new TagFolderSettingTab(this.app, this));
    maxDepth.set(this.settings.expandLimit);
    if (this.settings.useTagInfo) {
      this.app.workspace.onLayoutReady(async () => {
        await this.loadTagInfo();
      });
    }
    searchString.subscribe((search) => {
      this.searchString = search;
      this.refreshAllTree(null);
    });
    const setTagSearchString = (event, tagString) => {
      if (tagString) {
        const regExpTagStr = new RegExp(`(^|\\s)${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u");
        const regExpTagStrInv = new RegExp(`(^|\\s)-${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u");
        if (event.altKey) {
          return;
        } else if (event.ctrlKey && event.shiftKey) {
          if (this.searchString.match(regExpTagStr)) {
            this.setSearchString(this.searchString.replace(regExpTagStr, ""));
          } else if (!this.searchString.match(regExpTagStrInv)) {
            this.setSearchString(this.searchString + (this.searchString.length == 0 ? "" : " ") + `-${tagString}`);
          }
        } else if (event.ctrlKey) {
          if (this.searchString.match(regExpTagStrInv)) {
            this.setSearchString(this.searchString.replace(regExpTagStrInv, ""));
          } else if (!this.searchString.match(regExpTagStr)) {
            this.setSearchString(this.searchString + (this.searchString.length == 0 ? "" : " ") + `${tagString}`);
          }
        } else {
          this.setSearchString(tagString);
        }
        event.preventDefault();
        event.stopPropagation();
      }
    };
    const selectorHashTagLink = 'a.tag[href^="#"]';
    const selectorHashTagSpan = "span.cm-hashtag.cm-meta";
    this.register(
      onElement(document, "click", selectorHashTagLink, (event, targetEl) => {
        if (!this.settings.overrideTagClicking)
          return;
        const tagString = targetEl.innerText.substring(1);
        if (tagString) {
          setTagSearchString(event, tagString);
        }
      }, { capture: true })
    );
    this.register(
      onElement(document, "click", selectorHashTagSpan, (event, targetEl) => {
        if (!this.settings.overrideTagClicking)
          return;
        let enumTags = targetEl;
        let tagString = "";
        while (!enumTags.classList.contains("cm-hashtag-begin")) {
          enumTags = enumTags.previousElementSibling;
          if (!enumTags) {
            console.log("Error! start tag not found.");
            return;
          }
        }
        do {
          if (enumTags instanceof HTMLElement) {
            tagString += enumTags.innerText;
            if (enumTags.classList.contains("cm-hashtag-end")) {
              break;
            }
          }
          enumTags = enumTags.nextElementSibling;
        } while (enumTags);
        tagString = tagString.substring(1);
        setTagSearchString(event, tagString);
      }, { capture: true })
    );
    selectedTags.subscribe((newTags) => {
      this.openListView(newTags);
    });
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  sortChildren(a, b) {
    if ("tag" in a && !("tag" in b)) {
      return -1;
    } else if (!("tag" in a) && "tag" in b) {
      return 1;
    } else {
      if ("tag" in a && "tag" in b) {
        return this.compareTags(a, b, this.tagInfo);
      } else if ("tags" in a && "tags" in b) {
        return this.compareItems(a, b);
      } else {
        return 0;
      }
    }
  }
  sortTree(entry) {
    entry.children = entry.children.sort(this.sortChildren);
    for (const child of entry.children) {
      if ("tag" in child) {
        this.sortTree(child);
      }
    }
    entry.descendants = entry.descendants.sort(this.sortChildren);
  }
  snipEmpty(root) {
    for (const v of root.children) {
      if ("tag" in v)
        this.snipEmpty(v);
    }
    root.children = root.children.filter((e) => !("tag" in e && e.children.length == 0));
  }
  mergeRedundantCombination(root) {
    const existentChild = {};
    const removeChildren = [];
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      if ("tag" in entry)
        this.mergeRedundantCombination(entry);
    }
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      const tags = [...new Set(retrieveAllDescendants(entry))].map((e) => e.path).sort().join("-");
      if (tags in existentChild) {
        removeChildren.push(entry);
      } else {
        existentChild[tags] = entry;
      }
    }
    for (const v of removeChildren) {
      root.children.remove(v);
    }
    root.children = [...root.children];
  }
  setRoot(root) {
    var _a;
    rippleDirty(root);
    expandDescendants(root, this.settings.hideItems);
    this.snipEmpty(root);
    this.sortTree(root);
    if (this.settings.mergeRedundantCombination)
      this.mergeRedundantCombination(root);
    this.root = root;
    (_a = this.getView()) == null ? void 0 : _a.setTreeRoot(root);
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = [...this.app.vault.getMarkdownFiles(), ...this.app.vault.getAllLoadedFiles().filter((e) => "extension" in e && e.extension == "canvas")];
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter(
        (fileCache) => fileCache.file.path != diff.path
      );
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
    const fileCacheDump = JSON.stringify(
      this.fileCaches.map((e) => {
        var _a, _b;
        return {
          path: e.file.path,
          tags: ((_b = (_a = e.metadata) == null ? void 0 : _a.tags) != null ? _b : []).map((e2) => e2.tag)
        };
      })
    );
    if (this.oldFileCache == fileCacheDump) {
      return false;
    } else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  async getItemsList() {
    var _a;
    const items = [];
    const ignoreDocTags = this.settings.ignoreDocTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    const ignoreTags = this.settings.ignoreTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    const ignoreFolders = this.settings.ignoreFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const targetFolders = this.settings.targetFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const searchItems = this.searchString.toLocaleLowerCase().split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
    const today = Date.now();
    for (const fileCache of this.fileCaches) {
      if (targetFolders.length > 0 && !targetFolders.some(
        (e) => {
          return e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e);
        }
      )) {
        continue;
      }
      if (ignoreFolders.some(
        (e) => e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e)
      )) {
        continue;
      }
      await doEvents();
      const tagRedirectList = {};
      if (this.settings.useTagInfo && this.tagInfo) {
        for (const [key, taginfo] of Object.entries(this.tagInfo)) {
          if ("redirect" in taginfo) {
            tagRedirectList[key] = taginfo.redirect;
          }
        }
      }
      const allTagsDocs = unique((_a = (0, import_obsidian6.getAllTags)(fileCache.metadata)) != null ? _a : []);
      let allTags2 = unique(allTagsDocs.map((e) => e.substring(1)).map((e) => e in tagRedirectList ? tagRedirectList[e] : e));
      if (this.settings.disableNestedTags) {
        allTags2 = allTags2.map((e) => e.split("/")).flat();
      }
      if (allTags2.length == 0) {
        allTags2 = ["_untagged"];
      }
      if (fileCache.file.extension == "canvas") {
        allTags2.push("_VIRTUAL_TAG_CANVAS");
      }
      if (this.settings.useVirtualTag) {
        const mtime = fileCache.file.stat.mtime;
        const diff = today - mtime;
        const disp = secondsToFreshness(diff);
        allTags2.push(`_VIRTUAL_TAG_FRESHNESS/${disp}`);
      }
      if (allTags2.some(
        (tag) => ignoreDocTags.contains(tag.toLocaleLowerCase())
      )) {
        continue;
      }
      const w = searchItems.map((searchItem) => {
        let bx = false;
        for (const search of searchItem) {
          if (search.startsWith("-")) {
            bx = bx || allTags2.some(
              (tag) => tag.toLocaleLowerCase().contains(search.substring(1))
            );
          } else {
            bx = bx || allTags2.every(
              (tag) => !tag.toLocaleLowerCase().contains(search)
            );
          }
        }
        return bx;
      });
      if (w.every((e) => e))
        continue;
      allTags2 = allTags2.filter(
        (tag) => !ignoreTags.contains(tag.toLocaleLowerCase())
      );
      items.push({
        tags: allTags2,
        path: fileCache.file.path,
        displayName: this.getDisplayName(fileCache.file),
        ancestors: [],
        mtime: fileCache.file.stat.mtime,
        ctime: fileCache.file.stat.ctime,
        filename: fileCache.file.basename
      });
    }
    return items;
  }
  async buildUpTree(items) {
    const archiveTags = this.settings.archiveTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    const archivedNotes = archiveTags.map((archiveTag) => [archiveTag, items.filter((item) => item.tags.some((tag) => tag.toLocaleLowerCase() == archiveTag))]);
    const root = {
      tag: "root",
      children: [...items.filter((e) => e.tags.every((tag) => !archiveTags.contains(tag.toLocaleLowerCase())))],
      ancestors: ["root"],
      descendants: null,
      allDescendants: null,
      itemsCount: 0,
      isDedicatedTree: false
    };
    for (const [archiveTag, items2] of archivedNotes) {
      root.children.push(
        {
          tag: archiveTag,
          children: items2,
          ancestors: ["root", archiveTag],
          descendants: null,
          allDescendants: null,
          itemsCount: 0,
          isDedicatedTree: false
        }
      );
    }
    await expandTree(root, this.settings.reduceNestedParent);
    root.children = root.children.filter((e) => "tag" in e);
    await splitTag(root, this.settings.reduceNestedParent);
    await this.expandLastExpandedFolders(root, true);
    return root;
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff).then((e) => {
    });
  }
  async loadFileInfoAsync(diff) {
    if (this.getView() == null)
      return;
    const strSetting = JSON.stringify(this.settings);
    const isSettingChanged = strSetting != this.lastSettings;
    const isSearchStringModified = this.searchString != this.lastSearchString;
    if (isSettingChanged) {
      this.lastSettings = strSetting;
    }
    if (isSearchStringModified) {
      this.lastSearchString = this.searchString;
    }
    if (!this.updateFileCaches(diff) && !isSearchStringModified && !isSettingChanged) {
      await this.applyUpdateIntoScroll(diff);
      return;
    }
    const items = await this.getItemsList();
    const root = await this.buildUpTree(items);
    this.setRoot(root);
    await this.applyUpdateIntoScroll(diff);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER_LIST);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_SCROLL);
  }
  async openScrollView(leaf, title, tagPath, files) {
    if (!leaf) {
      leaf = this.app.workspace.getLeaf("split");
    }
    await leaf.setViewState({
      type: VIEW_TYPE_SCROLL,
      active: true,
      state: { files: files.map((e) => ({ path: e })), title, tagPath }
    });
    this.app.workspace.revealLeaf(
      leaf
    );
  }
  findTreeItemFromPath(tagPath, root) {
    if (!root) {
      root = this.root;
    }
    if (root.children.some((e) => !("tag" in e))) {
      return root;
    }
    const paths = tagPath.split("/");
    paths.shift();
    const path = [];
    while (paths.length > 0) {
      path.push(paths.shift());
      const child = root.children.find((e) => "tag" in e && e.tag == path.join("/"));
      if (child) {
        return this.findTreeItemFromPath(paths.join("/"), child);
      }
    }
    return null;
  }
  async applyUpdateIntoScroll(file) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SCROLL);
    for (const leaf of leaves) {
      const view = leaf.view;
      const viewStat = { ...leaf.getViewState(), state: { ...view.getScrollViewState() } };
      if (file && view.isFileOpened(file.path)) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: viewStat.state.files.map((e) => e.path == file.path ? {
              path: file.path
            } : e)
          }
        };
        await leaf.setViewState(newStat);
      }
      const openedNode = this.findTreeItemFromPath(viewStat.state.tagPath);
      if (openedNode) {
        const newFilesArray = openedNode.allDescendants.map((e) => e.path);
        const newFiles = newFilesArray.sort().join("-");
        const oldFiles = viewStat.state.files.map((e) => e.path).sort().join("-");
        if (newFiles != oldFiles) {
          const newStat = {
            ...viewStat,
            state: {
              ...viewStat.state,
              files: newFilesArray.map((path) => {
                const old = viewStat.state.files.find((e) => e.path == path);
                if (old)
                  return old;
                return {
                  path
                };
              })
            }
          };
          await leaf.setViewState(newStat);
        }
      }
    }
  }
  async activateView() {
    this.loadFileInfo();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
    await this.app.workspace.getLeftLeaf(false).setViewState({
      type: VIEW_TYPE_TAGFOLDER,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)[0]
    );
  }
  async modifyFile(file) {
    if (!this.settings.useTagInfo)
      return;
    if (this.skipOnce) {
      this.skipOnce = false;
      return;
    }
    if (file.name == this.getTagInfoFilename()) {
      await this.loadTagInfo();
    }
  }
  getTagInfoFilename() {
    return (0, import_obsidian6.normalizePath)(this.settings.tagInfo);
  }
  getTagInfoFile() {
    const file = this.app.vault.getAbstractFileByPath(this.getTagInfoFilename());
    if (file instanceof import_obsidian6.TFile) {
      return file;
    }
    return null;
  }
  applyTagInfo() {
    if (this.tagInfo == null)
      return;
    if (!this.settings.useTagInfo)
      return;
    tagInfo.set(this.tagInfo);
    setTimeout(() => {
      if (this.root)
        this.setRoot(this.root);
    }, 10);
  }
  async loadTagInfo() {
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      this.tagInfo = {};
    const file = this.getTagInfoFile();
    if (file == null)
      return;
    const data = await this.app.vault.read(file);
    try {
      const bodyStartIndex = data.indexOf("\n---");
      if (!data.startsWith("---") || bodyStartIndex === -1) {
        return;
      }
      const yaml = data.substring(3, bodyStartIndex);
      const yamlData = (0, import_obsidian6.parseYaml)(yaml);
      const keys = Object.keys(yamlData);
      this.tagInfoBody = data.substring(bodyStartIndex + 5);
      this.tagInfoFrontMatterBuffer = yamlData;
      const newTagInfo = {};
      for (const key of keys) {
        const w = yamlData[key];
        if (!w)
          continue;
        if (typeof w != "object")
          continue;
        const keys2 = ["key", "mark", "alt", "redirect"];
        const entries = Object.entries(w).filter(([key2]) => keys2.some((e) => key2.contains(e)));
        if (entries.length == 0)
          continue;
        newTagInfo[key] = Object.fromEntries(entries);
      }
      this.tagInfo = newTagInfo;
      this.applyTagInfo();
    } catch (ex) {
      console.log(ex);
    }
  }
  async saveTagInfo() {
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      return;
    let file = this.getTagInfoFile();
    if (file == null) {
      file = await this.app.vault.create(this.getTagInfoFilename(), "");
    }
    await app.fileManager.processFrontMatter(file, (matter) => {
      const ti = Object.entries(this.tagInfo);
      for (const [key, value] of ti) {
        if (value === void 0) {
          delete matter[key];
        } else {
          matter[key] = value;
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    await this.loadTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
    this.compareTags = getCompareMethodTags(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.saveTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
    this.compareTags = getCompareMethodTags(this.settings);
  }
  async openListView(tagSrc) {
    var _a;
    if (!tagSrc)
      return;
    const tags = tagSrc.first() == "root" ? tagSrc.slice(1) : tagSrc;
    let theLeaf;
    for (const leaf of this.app.workspace.getLeavesOfType(
      VIEW_TYPE_TAGFOLDER_LIST
    )) {
      const state = leaf.getViewState();
      if (state.state.tags.slice().sort().join("-") == tags.slice().sort().join("-")) {
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
        return;
      }
      if (state.pinned) {
      } else {
        theLeaf = leaf;
      }
    }
    if (!theLeaf) {
      const parent = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) == null ? void 0 : _a.first();
      if (!parent) {
        return;
      }
      if (!import_obsidian6.Platform.isMobile) {
        theLeaf = this.app.workspace.createLeafBySplit(parent, "horizontal", false);
      } else {
        theLeaf = this.app.workspace.getLeftLeaf(false);
      }
    }
    const title = tags.map(
      (e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/")
    ).join(" ");
    await theLeaf.setViewState({
      type: VIEW_TYPE_TAGFOLDER_LIST,
      active: true,
      state: { tags, title }
    });
    theLeaf.view.setTreeRoot(this.root);
    this.app.workspace.revealLeaf(
      theLeaf
    );
  }
};
var TagFolderSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for TagFolder" });
    containerEl.createEl("h3", { text: "Behavior" });
    new import_obsidian6.Setting(containerEl).setName("Always Open").setDesc("Open TagFolder automatically when obsidian has been launched").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange(async (value) => {
        this.plugin.settings.alwaysOpen = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Use pinning").setDesc(
      "When this feature is enabled, the pin information is saved in the file set in the next configuration."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTagInfo).onChange(async (value) => {
        this.plugin.settings.useTagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
        pi.setDisabled(!value);
      });
    });
    const pi = new import_obsidian6.Setting(containerEl).setName("Pin information file").setDisabled(!this.plugin.settings.useTagInfo).addText((text2) => {
      text2.setValue(this.plugin.settings.tagInfo).onChange(async (value) => {
        this.plugin.settings.tagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Files" });
    new import_obsidian6.Setting(containerEl).setName("Display method").setDesc("How to show a title of files").addDropdown(
      (dropdown) => dropdown.addOptions({
        "PATH/NAME": "PATH/NAME",
        NAME: "NAME",
        "NAME : PATH": "NAME : PATH"
      }).setValue(this.plugin.settings.displayMethod).onChange(async (value) => {
        this.plugin.settings.displayMethod = value;
        this.plugin.loadFileInfo(null);
        await this.plugin.saveSettings();
      })
    );
    const setOrderMethod = async (key, order) => {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      await this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    };
    new import_obsidian6.Setting(containerEl).setName("Order method").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian6.Setting(containerEl).setName("Use title").setDesc(
      "Use value in the frontmatter or first level one heading for `NAME`."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTitle).onChange(async (value) => {
        this.plugin.settings.useTitle = value;
        fpath.setDisabled(!value);
        await this.plugin.saveSettings();
      });
    });
    const fpath = new import_obsidian6.Setting(containerEl).setName("Frontmatter path").setDisabled(!this.plugin.settings.useTitle).addText((text2) => {
      text2.setValue(this.plugin.settings.frontmatterKey).onChange(async (value) => {
        this.plugin.settings.frontmatterKey = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Tags" });
    const setOrderMethodTag = async (key, order) => {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      await this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    };
    new import_obsidian6.Setting(containerEl).setName("Order method").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian6.Setting(containerEl).setName("Use virtual tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useVirtualTag).onChange(async (value) => {
        this.plugin.settings.useVirtualTag = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Actions" });
    new import_obsidian6.Setting(containerEl).setName("Search tags inside TagFolder when clicking tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overrideTagClicking).onChange(async (value) => {
        this.plugin.settings.overrideTagClicking = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("List files in a separated pane").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useMultiPaneList).onChange(async (value) => {
        this.plugin.settings.useMultiPaneList = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Arrangements" });
    new import_obsidian6.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown((dd) => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange(async (key) => {
        if (key == "NONE" || key == "DEDICATED_INTERMIDIATES" || key == "ALL_EXCEPT_BOTTOM") {
          this.plugin.settings.hideItems = key;
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Merge redundant combinations").setDesc(
      "When this feature is enabled, a/b and b/a are merged into a/b if there is no intermediates."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.mergeRedundantCombination).onChange(async (value) => {
        this.plugin.settings.mergeRedundantCombination = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Do not simplify empty folders").setDesc(
      "Keep empty folders, even if they can be simplified."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.doNotSimplifyTags).onChange(async (value) => {
        this.plugin.settings.doNotSimplifyTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange(async (value) => {
        this.plugin.settings.disableNestedTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Reduce duplicated parents in nested tags").setDesc("If enabled, #web/css, #web/javascript will merged into web -> css -> javascript").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.reduceNestedParent).onChange(async (value) => {
        this.plugin.settings.reduceNestedParent = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Filters" });
    new import_obsidian6.Setting(containerEl).setName("Target Folders").setDesc("If configured, the plugin will only target files in it.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.targetFolders).setPlaceholder("study,documents/summary").onChange(async (value) => {
        this.plugin.settings.targetFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange(async (value) => {
        this.plugin.settings.ignoreFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore note Tag").setDesc(
      "If the note has the tag listed below, the note would be treated as there was not."
    ).addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
        this.plugin.settings.ignoreDocTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
        this.plugin.settings.ignoreTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Archive tags").setDesc("If configured, notes with these tags will be moved under the tag.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.archiveTags).setPlaceholder("archived, discontinued").onChange(async (value) => {
        this.plugin.settings.archiveTags = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Misc" });
    new import_obsidian6.Setting(containerEl).setName("Tag scanning delay").setDesc(
      "Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)"
    ).addText((text2) => {
      text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange(async (value) => {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          await this.plugin.saveSettings();
        }
      });
      text2.inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
    containerEl.createEl("h3", { text: "Utilities" });
    new import_obsidian6.Setting(containerEl).setName("Dumping tags for reporting bugs").setDesc(
      "If you want to open an issue to the GitHub, this information can be useful. and, also if you want to keep secrets about names of tags, you can use `disguised`."
    ).addButton((button) => button.setButtonText("Copy tags").setDisabled(false).onClick(async () => {
      const items = this.plugin.root.allDescendants.map((e) => e.tags.filter((e2) => e2 != "_untagged")).filter((e) => e.length);
      await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#${e2}`).join(", ")).join("\n"));
      new import_obsidian6.Notice("Copied to clipboard");
    })).addButton(
      (button) => button.setButtonText("Copy disguised tags").setDisabled(false).onClick(async () => {
        const x = /* @__PURE__ */ new Map();
        let i = 0;
        const items = this.plugin.root.allDescendants.map((e) => e.tags.filter((e2) => e2 != "_untagged").map((e2) => x.has(e2) ? x.get(e2) : (x.set(e2, i++), i))).filter((e) => e.length);
        await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#tag${e2}`).join(", ")).join("\n"));
        new import_obsidian6.Notice("Copied to clipboard");
      })
    );
  }
};
